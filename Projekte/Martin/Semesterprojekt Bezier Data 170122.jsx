//@includepath "~/Documents/;%USERPROFILE%Documents";//@include "basiljs/basil.js";// this script demonstrates how to collect anchor point coordinates of letters in InDesignfunction draw() {  b.clear(b.doc());  var possibleLetters = ["a","b", "A"]  /*"c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","ä","ö","ü","ß","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","ä","ö","ü","1","2","3","4","5","6","7","8","9","0","!","?",":",".",";",",","%","&","/","(",")","[","]","{","}","§*/  // Anlegen eines Info-Objekts, das ein leeres Objekt für die bounds enthält und einen leeren Array für die Pfade  // "Paths" muss Indikator enthalten  var letterInfo = {  };// dieser loop durchläuft das Array possibleLettersfor ( var k = 0; k < possibleLetters.length; k ++) {  var myLetter = possibleLetters[k];  letterInfo[myLetter] = [];  // Textrahmen erstellen  b.textSize(72);  var tf = b.text(myLetter, 0, 0, 100, 100);  // Textrahmen in Pfade umwandeln  tf.createOutlines();  // beim entstandenen Pfad wird der Befehl "Verknüpften Pfad lösen" abgerufen  // falls der Pfad ein verknüpfter Pfad war (Buchstabe mit Punzen) wird er damit in seine Einzelteile zerlegt  var myOutline = b.doc().pageItems[0];  myOutline.releaseCompoundPath();  // alle entstandenen Pfae werden in die Variable myPaths geladen  var myPaths = b.doc().pageItems;  // ein Loop ruft von jedem Pfad alle Punkte ab  // von jedem Pfadpunkt wird ein Array mit dem linken, dem mittleren und dem rechten Ankerpunkt erstellt  // das Format ist also [ [xl, yl], [x, y], [xr, yr] ]  // diese Punktarrays werden wiederum in einem Array collectedPathPoints gesammelt  // wenn dieser fertig geschrieben ist wird er im Array letterInfo.paths mit allen Pfaden des Buchstabens gespeichert  //  // die Schleife wird rückwärts durchlaufen, da die Punzen an erster Stelle im Dokument stehen. Auf diese Weise ist der Buchstabenumriss das erste Element im Array.  for ( var i = myPaths.length - 1; i >= 0; i-- ) {    var myPathPoints = myPaths[i].paths[0].pathPoints;    for ( var j = 0; j < myPathPoints.length ; j++ ) {      // Achterpaket      var pointObject = {};      if ( j < myPathPoints.length - 1) {                       pointObject.p0x = myPathPoints[j].anchor[0], pointObject.p0y = myPathPoints[j].anchor[1],                       pointObject.cp0x = myPathPoints[j].rightDirection[0], pointObject.cp0y = myPathPoints[j].rightDirection[1],                       pointObject.cp1x = myPathPoints[j + 1].leftDirection[0], pointObject.cp1y = myPathPoints[j + 1].leftDirection[1],                       pointObject.p1x = myPathPoints[j + 1].anchor[0], pointObject.p1y = myPathPoints[j + 1].anchor[1] ;      } else ( j === myPathPoints.length ) {                       pointObject.p0x = myPathPoints[j].anchor[0], pointObject.p0y = myPathPoints[j].anchor[1],                       pointObject.cp0x = myPathPoints[j].rightDirection[0], pointObject.cp0y = myPathPoints[j].rightDirection[1],                       pointObject.cp1x = myPathPoints[0].leftDirection[0], pointObject.cp1y = myPathPoints[0].leftDirection[1],                       pointObject.p1x = myPathPoints[0].anchor[0], pointObject.p1y = myPathPoints[0].anchor[1]   }    letterInfo[myLetter].push(pointObject);  }}  //collectedPathPoints.splice(0, collectedPathPoints.length);  // Resultat in die Konsole schreiben  b.inspect(letterInfo); b.clear(b.doc());} // Resultat als JSON-Datei abspeichern  var exportString = b.JSON.encode(letterInfo);  b.saveString("test.json", exportString);}b.go();